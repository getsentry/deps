{"analyzedAt":"2021-07-30T15:51:55.722Z","collected":{"metadata":{"name":"downsample","scope":"unscoped","version":"1.4.0","description":"Provides functions for time series data downsampling for visual representation","keywords":["downsample","data","downsampling","charts","charting","plot","plotting"],"date":"2021-02-24T07:25:31.468Z","author":{"name":"Jan Jakub Nanista","email":"jan.jakub.nanista@gmail.com","username":"jannanista"},"publisher":{"username":"jannanista","email":"jan.jakub.nanista@gmail.com"},"maintainers":[{"username":"jannanista","email":"jan.jakub.nanista@gmail.com"}],"repository":{"type":"git","url":"git+https://github.com/janjakubnanista/downsample.git"},"links":{"npm":"https://www.npmjs.com/package/downsample","homepage":"https://github.com/janjakubnanista/downsample","repository":"https://github.com/janjakubnanista/downsample","bugs":"https://github.com/janjakubnanista/downsample/issues"},"license":"MIT","devDependencies":{"@babel/core":"^7.10.2","@babel/preset-typescript":"^7.10.1","@types/jest":"^25.2.3","@types/node":"^14.0.11","@typescript-eslint/eslint-plugin":"^3.1.0","@typescript-eslint/parser":"^3.1.0","@wessberg/rollup-plugin-ts":"^1.2.17","babel-core":"^6.26.3","babel-eslint":"^10.1.0","babel-loader":"^8.1.0","babel-preset-env":"^1.7.0","babel-preset-react":"^6.24.1","eslint":"^7.2.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.3","eslint-plugin-react":"^7.20.0","eslint-plugin-sort-imports-es6-autofix":"^0.5.0","husky":"^4.2.5","jest":"^26.0.1","lint-staged":"^10.2.9","prettier":"^2.0.5","rollup":"^2.14.0","rollup-plugin-commonjs":"^10.1.0","rollup-plugin-node-resolve":"^5.2.0","ts-jest":"^26.1.0","ts-loader":"^7.0.5","ts-node":"^8.10.2","ts-type-checked":"^0.3.5","ttypescript":"^1.5.10","typescript":"^3.9.5"},"releases":[{"from":"2021-06-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":0},{"from":"2021-05-01T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":0},{"from":"2021-01-31T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":2},{"from":"2020-07-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":2},{"from":"2019-07-31T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":5}],"hasTestScript":true,"hasSelectiveFiles":true,"readme":"<h1 align=\"center\">\n  downsample\n</h1>\n\n<p align=\"center\">\n  Downsampling methods for time series visualisation.\n</p>\n\n<!-- The badges section -->\n<p align=\"center\">\n  <!-- Travis CI build status -->\n  <a href=\"https://travis-ci.org/janjakubnanista/downsample\"><img alt=\"Build Status\" src=\"https://travis-ci.org/janjakubnanista/downsample.svg?branch=master\"/></a>\n  <!-- Fury.io NPM published package version -->\n  <a href=\"https://www.npmjs.com/package/downsample\"><img alt=\"NPM Version\" src=\"https://badge.fury.io/js/downsample.svg\"/></a>\n  <!-- Shields.io dev dependencies status -->\n  <a href=\"https://github.com/janjakubnanista/downsample/blob/master/package.json\"><img alt=\"Dev Dependency Status\" src=\"https://img.shields.io/david/dev/janjakubnanista/downsample\"/></a>\n  <!-- Snyk.io vulnerabilities badge -->\n  <a href=\"https://snyk.io/test/github/janjakubnanista/downsample\"><img alt=\"Known Vulnerabilities\" src=\"https://snyk.io/test/github/janjakubnanista/downsample/badge.svg\"/></a>\n  <!-- Shields.io license badge -->\n  <a href=\"https://github.com/janjakubnanista/downsample/blob/master/LICENSE\"><img alt=\"License\" src=\"https://img.shields.io/npm/l/downsample\"/></a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#installation\">Installation</a>\n  <span>|</span>\n  <a href=\"#usage\">Usage</a>\n  <span>|</span>\n  <a href=\"#api\">API</a>\n  <span>|</span>\n  <a href=\"#demo\">Demo</a>\n  <span>|</span>\n  <a href=\"#acknowledgement\">Acknowledgement</a>\n</p>\n\n`downsample` is useful when, not extremely surprisingly, you need to downsample a numeric time series before visualizing it without losing the visual characteristics of the data.\n\n<a id=\"installation\"></a>\n## Installation\n\n[downsample](https://www.npmjs.com/package/downsample) is an NPM module. You can easily download it by typing something like the following in your project:\n\n```bash\n# for all the npm people out there\nnpm install downsample\n\n# or if you are a fan of yarn\nyarn add downsample\n```\n\n<a id=\"usage\"></a>\n## Usage\n\nThe package exports several methods for data downsampling:\n\n- **ASAP** Automatic Smoothing for Attention Prioritization [read more here](http://futuredata.stanford.edu/asap/)\n- **SMA** Simple moving average [read more here](https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average)\n- **LTTB** Largest triangle three buckets [read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n- **LTOB** Largest triangle one bucket [read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n- **LTD** Largest triangle dynamic [read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n\nYou can read more about the details of these in the [API](#api) section below.\n\n<a id=\"api\"></a>\n## API\n\n<a id=\"api/ASAP\"></a>\n### `ASAP` :boom: *new in 1.2.0* :boom:\n\nAutomatic Smoothing for Attention Prioritization ([read more here](http://futuredata.stanford.edu/asap/)) is a smoothing rather than downsampling method - it will remove the short-term noise and reveal the large-scale deviations.\n\n`ASAP` accepts an array of data points (see [DataPoint](#api/DataPoint)) or a `TypedArray` (see [TypedArray support](#api/TypedArray)) and a target resolution (number of output data points) as arguments. It will always return the points in `XYDataPoint` format. [See advanced API if you need to work with a custom data type](#api/createASAP).\n\n```typescript\nfunction ASAP(data: DataPoint[], targetResolution: number): XYDataPoint[]\n```\n\n```typescript\nimport { ASAP } from 'downsample';\n\n// Or if your codebase does not supprot tree-shaking\nimport { ASAP } from 'downsample/methods/ASAP';\n\nconst chartWidth = 1000;\nconst smooth = ASAP([\n  [0, 1000],\n  [1, 1243],\n  // ...\n], chartWidth);\n```\n\n<a id=\"api/SMA\"></a>\n### `SMA` :boom: *new in 1.2.0* :boom:\n\nSimple moving average with variable slide ([read more here](https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average)).\n\n`SMA` accepts an array of data points (see [DataPoint](#api/DataPoint)) or a `TypedArray` (see [TypedArray support](#api/TypedArray)), size of a window over which to calculate average and a slide - an amount by which the window is shifted. It will always return the points in `XYDataPoint` format. [See advanced API if you need to work with a custom data type](#api/createSMA).\n\n```typescript\nfunction SMA(data: DataPoint[], windowSize: number, slide?: number = 1): XYDataPoint[]\n```\n\n```typescript\nimport { SMA } from 'downsample';\n\n// Or if your codebase does not supprot tree-shaking\nimport { SMA } from 'downsample/methods/SMA';\n\nconst chartWidth = 1000;\nconst smooth = SMA([\n  [0, 1000],\n  [1, 1243],\n  // ...\n], chartWidth);\n```\n\n<a id=\"api/LTTB\"></a>\n### `LTTB`\n\nLargest triangle three buckets ([read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)). If you are looking for the best performing downsampling method then look no more!\n\n```typescript\nfunction LTTB(data: DataPoint[], targetResolution: number): DataPoint[]\n```\n\n`LTTB` accepts an array of data points (see [DataPoint](#api/DataPoint)) or a `TypedArray` (see [TypedArray support](#api/TypedArray)) and a target resolution (number of output data points) as arguments. [See advanced API if you need to work with a custom data type](#api/createLTTB).\n\nThe format of the data will be preserved, i.e. if passing an array of `[number, number]` data points as `data`, you will get an array of `[number, number]` on the output.\n\n```typescript\nimport { LTTB } from 'downsample';\n\n// Or if your codebase does not supprot tree-shaking\nimport { LTTB } from 'downsample/methods/LTTB';\n\nconst chartWidth = 1000;\nconst downsampled = LTTB([\n  [0, 1000],\n  [1, 1243],\n  // ...\n], chartWidth);\n```\n\n<a id=\"api/LTOB\"></a>\n### `LTOB`\n\nLargest triangle one bucket ([read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)). Performs only slightly worse than LTTB.\n\n```typescript\nfunction LTOB(data: DataPoint[], targetResolution: number): DataPoint[]\n```\n\n`LTOB` accepts an array of data points (see [DataPoint](#api/DataPoint)) or a `TypedArray` (see [TypedArray support](#api/TypedArray)) and a target resolution (number of output data points) as arguments. [See advanced API if you need to work with a custom data type](#api/createLTOB).\n\nThe format of the data will be preserved, i.e. if passing an array of `[number, number]` data points as `data`, you will get an array of `[number, number]` on the output.\n\n```typescript\nimport { LTOB } from 'downsample';\n\n// Or if your codebase does not supprot tree-shaking\nimport { LTOB } from 'downsample/methods/LTOB';\n\nconst chartWidth = 1000;\nconst downsampled = LTOB([\n  [0, 1000],\n  [1, 1243],\n  // ...\n], chartWidth);\n```\n\n<a id=\"api/LTD\"></a>\n### `LTD`\n\nLargest triangle dynamic ([read more here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)). The simplest downsampling method.\n\n```typescript\nfunction LTD(data: DataPoint[], targetResolution: number): DataPoint[]\n```\n\n`LTD` accepts an array of data points (see [DataPoint](#api/DataPoint)) or a `TypedArray` (see [TypedArray support](#api/TypedArray)) and a target resolution (number of output data points) as arguments. [See advanced API if you need to work with a custom data type](#api/createLTD).\n\nThe format of the data will be preserved, i.e. if passing an array of `[number, number]` data points as `data`, you will get an array of `[number, number]` on the output.\n\n```typescript\nimport { LTD } from 'downsample';\n\n// Or if your codebase does not supprot tree-shaking\nimport { LTD } from 'downsample/methods/LTD';\n\nconst chartWidth = 1000;\nconst downsampled = LTD([\n  [0, 1000],\n  [1, 1243],\n  // ...\n], chartWidth);\n```\n\n<a id=\"api/DataPoint\"></a>\n### `DataPoint` type\n\nRepresents a data point in the input data array. These formats are currently supported:\n\n```typescript\ntype DataPoint =\n  [number, number] |\n  [Date, number] |\n  { x: number; y: number } |\n  { x: Date; y: number } |\n```\n\n<a id=\"api/TypedArray\"></a>\n### `TypedArray` support\n\nIt is now possible to pass `TypedArray` data to downsampling functions. The returned type will then match the input type, e.g. if `Int16Array` is passed in, the result will be a `Int16Array`:\n\n```typescript\nconst input: Int16Array = new Int16Array(...);\nconst result: Int16Array = LTD(input, 1000);\n```\n\n## Advanced API\n\nAll the functions above work with `DataPoint` objects as a reasonable default. If however this does not fit your needs you can create your own version of a function using a downsampling function factory.\n\n<a id=\"api/createASAP\"></a>\n### `createASAP`\n\nCreates an [ASAP](#api/ASAP) smoothing function for a specific point data type `P`.\n\n```typescript\nfunction createASAP({\n  x: string | number | (point: P) => number,\n  y: string | number | (point: P) => number,\n  toPoint: (x: number, y: number) => P\n}): ASAP;\n```\n\n<a id=\"api/createSMA\"></a>\n### `createSMA`\n\nCreates a [SMA](#api/SMA) smoothing function for a specific point data type `P`.\n\n```typescript\nfunction createSMA({\n  x: string | number | (point: P) => number,\n  y: string | number | (point: P) => number,\n  toPoint: (x: number, y: number) => P\n}): SMA;\n```\n\n<a id=\"api/createLTD\"></a>\n### `createLTD`\n\nCreates an [LTD](#api/LTD) downsampling function for a specific point data type `P`.\n\n```typescript\nfunction createLTD({\n  x: string | number | (point: P) => number,\n  y: string | number | (point: P) => number\n}): LTD;\n```\n\n<a id=\"api/createLTOB\"></a>\n### `createLTOB`\n\nCreates an [LTOB](#api/LTOB) downsampling function for a specific point data type `P`.\n\n```typescript\nfunction createLTOB({\n  x: string | number | (point: P) => number,\n  y: string | number | (point: P) => number\n}): LTOB;\n```\n\n<a id=\"api/createLTTB\"></a>\n### `createLTTB`\n\nCreates an [LTTB](#api/LTTB) downsampling function for a specific point data type `P`.\n\n```typescript\nfunction createLTTB({\n  x: string | number | (point: P) => number,\n  y: string | number | (point: P) => number\n}): LTTB;\n```\n\n<a id=\"demo\"></a>\n## Demo\n\nThere is a very minimal interactive demo app available if you want to play around with the results of downsampling. [Check it out here](https://janjakubnanista.github.io/downsample/).\n\n<a id=\"acknowledgement\"></a>\n## Acknowledgement\n\nThe implementation of `LTD`, `LTOB` and `LTTB` is based on Sveinn Steinarsson's 2013 paper _Downsampling Time Series for\nVisual Representation_ that can be found [here](https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf).\n\nThe implementation of `ASAP` is based on Kexin Rong's and Peter Bailis's 2017 paper. _ASAP: Prioritizing Attention via Time Series Smoothing_ that can be found [here](https://arxiv.org/pdf/1703.00983.pdf). The original code can be found [here](https://github.com/stanford-futuredata/ASAP/blob/master/ASAP-optimized.js)"},"npm":{"downloads":[{"from":"2021-07-29T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":845},{"from":"2021-07-23T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":4237},{"from":"2021-06-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":21015},{"from":"2021-05-01T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":51923},{"from":"2021-01-31T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":98469},{"from":"2020-07-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":140164}],"dependentsCount":3,"starsCount":0},"github":{"starsCount":36,"forksCount":5,"subscribersCount":3,"issues":{"count":32,"openCount":12,"distribution":{"3600":13,"10800":2,"32400":0,"97200":0,"291600":1,"874800":1,"2624400":2,"7873200":8,"23619600":3,"70858800":2,"212576400":0},"isDisabled":false},"contributors":[{"username":"janjakubnanista","commitsCount":81}],"commits":[{"from":"2021-07-23T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":0},{"from":"2021-06-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":0},{"from":"2021-05-01T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":0},{"from":"2021-01-31T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":9},{"from":"2020-07-30T00:00:00.000Z","to":"2021-07-30T00:00:00.000Z","count":10}],"statuses":[{"context":"ci/circleci: publish","state":"failure"},{"context":"ci/circleci: release/approve","state":"success"},{"context":"ci/circleci: build-and-test","state":"success"},{"context":"continuous-integration/travis-ci/push","state":"failure"},{"context":"ci/circleci: release/kickoff","state":"success"}]},"source":{"files":{"readmeSize":10728,"testsSize":51413027,"hasChangelog":true},"badges":[{"urls":{"original":"https://travis-ci.org/janjakubnanista/downsample.svg?branch=master","service":"https://api.travis-ci.org/janjakubnanista/downsample.svg?branch=master","shields":"https://img.shields.io/travis/janjakubnanista/downsample/master.svg","content":"https://img.shields.io/travis/janjakubnanista/downsample/master.json"},"info":{"service":"travis","type":"build","modifiers":{"branch":"master"}}}],"linters":["eslint","prettier"]}},"evaluation":{"quality":{"carefulness":0.9999999999999999,"tests":0.75,"health":1,"branding":0.15},"popularity":{"communityInterest":45,"downloadsCount":17307.666666666668,"downloadsAcceleration":119.88202054794519,"dependentsCount":3},"maintenance":{"releasesFrequency":0.9,"commitsFrequency":0.9,"openIssues":0.9,"issuesDistribution":0.9}},"score":{"final":0.6787968128023246,"detail":{"quality":0.9518843981409003,"popularity":0.12365335716279796,"maintenance":0.9998651952945008}}}